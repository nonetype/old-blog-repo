---
layout: post
title: "malloc.c Analysis in Hacker's Perspective"
author: "nonetype"
---

malloc.c 분석기
> 이 글은 glibc 2.23 버전의 malloc.c 소스 코드를 분석하여 malloc, realloc, calloc, free 등의 함수의 동작 원리를 보고 hacker의 관점에서 어떤 방식으로 Exploit 할 수 있을지, 보호기법이나 익스플로잇 방법 등을 연구하는 문서입니다.
> 본 문서에서 분석하는 malloc.c(glibc2.23)은 소스 코드는[gnu glibc-2.23](https://ftp.gnu.org/gnu/glibc/glibc-2.23.tar.gz)에서 다운로드 받을 수 있습니다.

**일반적으로 프로그래밍을 할 때, `malloc(size_t size)` 함수를 사용하여 동적 메모리를 할당 받고, 할당 받은 메모리를 사용하고, `free(void* ptr)`함수를 통해 해당 메모리를 할당 해제하는 정도로만 이해하고 사용한다.
이번엔 조금 더 깊게, 어떻게 동적 메모리가 할당되고, 관리되고, 할당 해제되는지 확인해 보도록 하자.**

<!--
###0. allocation 함수의 종류
1. dlmalloc
  &nbsp;&nbsp;&nbsp;&nbsp;glibc의 ptmalloc의 기반이 되는 allocator
2. jemalloc (FreeBSD, NetBSD)
3. malloc (OpenBSD)
4. Hoard malloc
5. tcmalloc
-->
### 1. Heap 구조 분석(Chunks & Bins)
<!--Alloc / free될 때의 Heap Chunk/Bin 구조의 변화-->

우선 실제 프로그램에서 동적 메모리를 어떻게 관리하는지 알아보자.

> [링크]()에서 아래에서 사용하는 소스 코드를 받을 수 있다.
>
> 첨부 코드 실행 전에 **ASLR을 해제**해야 한다.
> ```sh
> nonetype@pwn:~/heap-analysis/src$ ls
> heap1  noASLR.sh
> nonetype@pwn:~/heap-analysis/src$ ./noASLR.sh
> [sudo] nonetype의 암호:
> kernel.randomize_va_space = 0
> nonetype@pwn:~/heap-analysis/src$
> ```

```c
#include <stdio.h>
#include <stdlib.h>

int main(int argc, char const *argv[]) {
  int* ptr = malloc(32);
  printf("malloc(32): [%p]\n", ptr);
  strcpy(ptr, "ABCD");
  printf("value: [%s]\n", ptr);
  free(ptr);
  printf("free(ptr) success!\n");
  return 0;
}
```
위 소스 코드를 gcc를 이용하여 컴파일한다.

```sh
nonetype@pwn:~/heap-analysis/src/heap1$ gcc -o heap1 heap1.c -no-pie -m32
nonetype@pwn:~/heap-analysis/src/heap1$ ls
heap1  heap1.c
```

heap1 파일이 정상적으로 컴파일 되었으니, 한번 실행해보자.
```sh
nonetype@pwn:~/heap-analysis/src/heap1$ ./heap1
malloc(32): [0x804b160]
value: [ABCD]
free(ptr) success!
nonetype@pwn:~/heap-analysis/src/heap1$
```
`malloc(32)`를 통해 0x804b160 주소에 정상적으로 동적 메모리가 할당되고, 해당 주소에 "ABCD" 값도 정상적으로 쓰이며, free도 정상적으로 이루어지는 듯 하다.
그렇다면 라이브러리 내부의 malloc, free 함수에서는 어떤 방식으로 동적 메모리를 할당하고, 관리하고, 해제해 주는지 확인해보자.

우선 heap1 파일을 gdb attach 한다.

```sh
nonetype@pwn:~/heap-analysis/src/heap1$ gdb ./heap1
Reading symbols from ./heap1...(no debugging symbols found)...done.
(gdb)
```

우선 어셈블리 코드를 보기 편하게 intel 문법으로 맞춰준다.

```sh
(gdb) set disassembly-flavor intel
(gdb)
```

이후 `main()` 함수의 어셈블리 코드를 확인해보자.

```sh
(gdb) disassemble main
Dump of assembler code for function main:
   0x080484b6 <+0>:	lea    ecx,[esp+0x4]
   0x080484ba <+4>:	and    esp,0xfffffff0
   0x080484bd <+7>:	push   DWORD PTR [ecx-0x4]
   0x080484c0 <+10>:	push   ebp
   0x080484c1 <+11>:	mov    ebp,esp
   0x080484c3 <+13>:	push   ebx
   0x080484c4 <+14>:	push   ecx
   0x080484c5 <+15>:	sub    esp,0x10
   0x080484c8 <+18>:	call   0x80483f0 <__x86.get_pc_thunk.bx>
   0x080484cd <+23>:	add    ebx,0x1b33
   0x080484d3 <+29>:	sub    esp,0xc
   0x080484d6 <+32>:	push   0x20
   0x080484d8 <+34>:	call   0x8048360 <malloc@plt>
   0x080484dd <+39>:	add    esp,0x10
   0x080484e0 <+42>:	mov    DWORD PTR [ebp-0xc],eax
   0x080484e3 <+45>:	sub    esp,0x8
   0x080484e6 <+48>:	push   DWORD PTR [ebp-0xc]
   0x080484e9 <+51>:	lea    eax,[ebx-0x1a30]
   0x080484ef <+57>:	push   eax
   0x080484f0 <+58>:	call   0x8048340 <printf@plt>
   0x080484f5 <+63>:	add    esp,0x10
   0x080484f8 <+66>:	mov    eax,DWORD PTR [ebp-0xc]
   0x080484fb <+69>:	mov    DWORD PTR [eax],0x44434241
   0x08048501 <+75>:	mov    BYTE PTR [eax+0x4],0x0
   0x08048505 <+79>:	sub    esp,0x8
   0x08048508 <+82>:	push   DWORD PTR [ebp-0xc]
   0x0804850b <+85>:	lea    eax,[ebx-0x1a1e]
   0x08048511 <+91>:	push   eax
   0x08048512 <+92>:	call   0x8048340 <printf@plt>
   0x08048517 <+97>:	add    esp,0x10
   0x0804851a <+100>:	sub    esp,0xc
   0x0804851d <+103>:	push   DWORD PTR [ebp-0xc]
   0x08048520 <+106>:	call   0x8048350 <free@plt>
   0x08048525 <+111>:	add    esp,0x10
   0x08048528 <+114>:	sub    esp,0xc
   0x0804852b <+117>:	lea    eax,[ebx-0x1a11]
   0x08048531 <+123>:	push   eax
   0x08048532 <+124>:	call   0x8048370 <puts@plt>
   0x08048537 <+129>:	add    esp,0x10
   0x0804853a <+132>:	mov    eax,0x0
   0x0804853f <+137>:	lea    esp,[ebp-0x8]
   0x08048542 <+140>:	pop    ecx
   0x08048543 <+141>:	pop    ebx
   0x08048544 <+142>:	pop    ebp
   0x08048545 <+143>:	lea    esp,[ecx-0x4]
   0x08048548 <+146>:	ret
End of assembler dump.
(gdb)
```

우선, `(1) 동적 메모리 할당 전` `(2) 동적 메모리 할당 후(값을 쓰기 전)` `(3) 값을 쓴 후` `(4) free 이후` 로 나누어 메모리를 확인해보자.

우선 breakpoint를 걸 위치를 정한다.
(1) `main + 34`
(2) `main + 69`
(3) `main + 75`
(4) `main + 111`

```sh
(gdb) b * main + 34
Breakpoint 1 at 0x80484d8
(gdb) b * main + 69
Breakpoint 2 at 0x80484fb
(gdb) b * main + 75
Breakpoint 3 at 0x8048501
(gdb) b * main + 111
Breakpoint 4 at 0x8048525
(gdb) r
Starting program: /home/nonetype/hack/pwn/heap/heap1

Breakpoint 1, 0x080484d8 in main ()
(gdb)
```

(1) 위치에 breakpoint가 걸렸다.
`malloc(32)`를 호출하기 전의 메모리 맵을 체크한다.

```sh
(gdb) info proc mapping
process 77216
Mapped address spaces:

	Start Addr   End Addr       Size     Offset objfile
	 0x8048000  0x8049000     0x1000        0x0 /home/nonetype/hack/pwn/heap/heap1
	 0x8049000  0x804a000     0x1000        0x0 /home/nonetype/hack/pwn/heap/heap1
	 0x804a000  0x804b000     0x1000     0x1000 /home/nonetype/hack/pwn/heap/heap1
	0xf7db9000 0xf7f8e000   0x1d5000        0x0 /lib/i386-linux-gnu/libc-2.27.so
	0xf7f8e000 0xf7f8f000     0x1000   0x1d5000 /lib/i386-linux-gnu/libc-2.27.so
	0xf7f8f000 0xf7f91000     0x2000   0x1d5000 /lib/i386-linux-gnu/libc-2.27.so
	0xf7f91000 0xf7f92000     0x1000   0x1d7000 /lib/i386-linux-gnu/libc-2.27.so
	0xf7f92000 0xf7f95000     0x3000        0x0
	0xf7fcf000 0xf7fd1000     0x2000        0x0
	0xf7fd1000 0xf7fd4000     0x3000        0x0 [vvar]
	0xf7fd4000 0xf7fd6000     0x2000        0x0 [vdso]
	0xf7fd6000 0xf7ffc000    0x26000        0x0 /lib/i386-linux-gnu/ld-2.27.so
	0xf7ffc000 0xf7ffd000     0x1000    0x25000 /lib/i386-linux-gnu/ld-2.27.so
	0xf7ffd000 0xf7ffe000     0x1000    0x26000 /lib/i386-linux-gnu/ld-2.27.so
	0xfffdd000 0xffffe000    0x21000        0x0 [stack]
(gdb)
```

malloc 함수 호출 전이기 때문에 프로세스 메모리에 heap 영역이 할당되지 않았다는 것을 확인할 수 있다.

이 상태에서 malloc을 진행하면 어떻게 되는지 확인해보자.

```sh
(gdb) c
Continuing.
malloc(32): [0x804b160]

Breakpoint 2, 0x080484fb in main ()
(gdb) info proc mapping
process 77216
Mapped address spaces:

	Start Addr   End Addr       Size     Offset objfile
	 0x8048000  0x8049000     0x1000        0x0 /home/nonetype/hack/pwn/heap/heap1
	 0x8049000  0x804a000     0x1000        0x0 /home/nonetype/hack/pwn/heap/heap1
	 0x804a000  0x804b000     0x1000     0x1000 /home/nonetype/hack/pwn/heap/heap1
	 0x804b000  0x806d000    0x22000        0x0 [heap]
	0xf7db9000 0xf7f8e000   0x1d5000        0x0 /lib/i386-linux-gnu/libc-2.27.so
	0xf7f8e000 0xf7f8f000     0x1000   0x1d5000 /lib/i386-linux-gnu/libc-2.27.so
	0xf7f8f000 0xf7f91000     0x2000   0x1d5000 /lib/i386-linux-gnu/libc-2.27.so
	0xf7f91000 0xf7f92000     0x1000   0x1d7000 /lib/i386-linux-gnu/libc-2.27.so
	0xf7f92000 0xf7f95000     0x3000        0x0
	0xf7fcf000 0xf7fd1000     0x2000        0x0
	0xf7fd1000 0xf7fd4000     0x3000        0x0 [vvar]
	0xf7fd4000 0xf7fd6000     0x2000        0x0 [vdso]
	0xf7fd6000 0xf7ffc000    0x26000        0x0 /lib/i386-linux-gnu/ld-2.27.so
	0xf7ffc000 0xf7ffd000     0x1000    0x25000 /lib/i386-linux-gnu/ld-2.27.so
	0xf7ffd000 0xf7ffe000     0x1000    0x26000 /lib/i386-linux-gnu/ld-2.27.so
	0xfffdd000 0xffffe000    0x21000        0x0 [stack]
(gdb)
```

`0x804b000` 위치에 heap 영역이 `0x22000` 크기로 할당되었다.

할당된 메모리를 확인해보면 다음과 같다.

```sh
(gdb) x/8wx 0x804b160
0x804b160:	0x00000000	0x00000000	0x00000000	0x00000000
0x804b170:	0x00000000	0x00000000	0x00000000	0x00000000
(gdb)
```

**하지만, 실제로 우리가 요청한 크기의 메모리가 정상적으로 할당되었는지 확인하려면 어떻게 해야 할까?**
여기서 확인해야 하는 것이 바로 Heap의 구조체, **Chunk**이다.

glibc malloc.c 내부에 선언되어 있는 chunk 구조체는 heap에서 사용자의 요청에 따라 할당된 메모리 블럭이라고 생각하면 된다.

`malloc.c` 내부에서는 청크를 다음과 같이 설명하고 있다.

```c
An allocated chunk looks like this:


chunk-> +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  |             Size of previous chunk, if allocated            | |
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  |             Size of chunk, in bytes                       |M|P|
  mem-> +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  |             User data starts here...                          .
  .                                                               .
  .             (malloc_usable_size() bytes)                      .
  .                                                               |
nextchunk-> +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  |             Size of chunk                                     |
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
```

실제 선언된 Chunk의 구조체는 다음과 같다.
```c
struct malloc_chunk {

  INTERNAL_SIZE_T      prev_size;  /* Size of previous chunk (if free).  */
  INTERNAL_SIZE_T      size;       /* Size in bytes, including overhead. */

  struct malloc_chunk* fd;         /* double links -- used only if free. */
  struct malloc_chunk* bk;

  /* Only used for large blocks: pointer to next larger size.  */
  struct malloc_chunk* fd_nextsize; /* double links -- used only if free. */
  struct malloc_chunk* bk_nextsize;
};
```

위 구조에 따르면, `malloc()` 함수 호출시 반환되는 메모리 포인터의 앞 8Byte(x64 16Byte) 부분에 Chunk Header가 존재한다는 것을 알 수 있고, 실제 청크는 청크가 반환되는 포인터 주소의 -8Byte 위치부터 시작된다는 것을 알 수 있다.
이제 Chunk의 Size를 확인하기 위해 실제 Chunk의 Header 부분을 확인해보자.

```sh
(gdb) x/8wx 0x804b160 - 8
0x804b158:	0x00000000	0x00000031	0x00000000	0x00000000
0x804b168:	0x00000000	0x00000000	0x00000000	0x00000000
(gdb)
```

확인해 보면 `malloc()`의 반환 포인터 주소인 `0x804b160`의 `-4` 위치에 `0x31`이라는 값이 들어가 있는 것을 확인할 수 있다.

분명 우리는 `32(0x20)`Byte를 할당했는데, 어째서 `0x31`이 Size 값이 되어 있을까?

우선, 실제 청크는 우리가 할당 요청한 크기인 `0x20`바이트 + 헤더 `0x8`바이트 크기이므로, 총 크기는 `0x28` 바이트가 된다. 이후, 메모리 연산 효율을 위해서 `0x10` 단위로 메모리 정렬을 시켜주기 때문에 크기가 `0x30`이 되고, FLAG 비트가 Size 필드의 1/2/3번째 비트에 붙기 때문에, 0x31이라는 크기 값이 설정되어 있는 것이다.

*"아니, 할당 요청한 0x20 바이트에서 실제 0x28 바이트가 되고, 메모리 정렬까진 알겠는데, **FLAG**는 또 뭐야?!"*

ptmalloc은 힙 청크 관리를 위해





# 추가중...







### 2. Heap 구조 분석(Arena)
Arean 구조
### 3. `malloc(size_t size)`의 동작 원리
malloc hook, malloc시 할당 방식, chunk 사용, exploit 가능성
### 4. `realloc()`의 동작 원리
alloc and free / etc..
### 5. `free()`의 동작 원리
chunk 합병, bins 관리 등등
### 6. Exploit Mitigations
security checks and bypass


<!-- TODO
```c {.line-numbers}
```
0. alloc 함수의 종류(malloc calloc kalloc 등등)
1. malloc 구조 분석(아레나)
2. malloc 구조 분석(청크 및 bins)
3. malloc 동작 방식(alloc, free)
4. 동작 방식 표
-->
ㅇ
