---
layout: post
title: "CVE-2018-10879 Analysis"
author: "nonetype"
---

CVE-2018-10879 Analysis

# 1. reproduce bug
[bugzilla](https://bugzilla.kernel.org/show_bug.cgi?id=200001)에 첨부되어 있는 poc 이미지를 다운로드 받아 KASan이 적용된 4.17버전 커널에서 마운트 후 poc 프로그램을 실행시켰다.

**poc.img**

[download](https://bugzilla.kernel.org/attachment.cgi?id=276405)

**poc.c**
```c
#define _GNU_SOURCE
#include <sys/types.h>
#include <sys/mount.h>
#include <sys/mman.h>
#include <sys/stat.h>
#include <sys/xattr.h>

#include <dirent.h>
#include <errno.h>
#include <error.h>
#include <fcntl.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

#include <linux/falloc.h>
#include <linux/loop.h>

static void activity(char *mpoint) {

  char *foo_bar_baz;
  char *foo_baz;
  int err;
  err = asprintf(&foo_bar_baz, "%s/foo/bar/baz", mpoint);
  err = asprintf(&foo_baz, "%s/foo/baz", mpoint);
  rename(foo_bar_baz, foo_baz);
}

int main(int argc, char *argv[]) {
  activity(argv[1]);
  return 0;
}
```

# Call Trace

Linux Kernel 4.17 기준
rename syscall은 아래 위치에 정의되어 있다.

**fs/namei.c:4634**
```c
SYSCALL_DEFINE5(renameat2, int, olddfd, const char __user *, oldname,
		int, newdfd, const char __user *, newname, unsigned int, flags)
{
	return do_renameat2(olddfd, oldname, newdfd, newname, flags);
}

SYSCALL_DEFINE4(renameat, int, olddfd, const char __user *, oldname,
		int, newdfd, const char __user *, newname)
{
	return do_renameat2(olddfd, oldname, newdfd, newname, 0);
}

SYSCALL_DEFINE2(rename, const char __user *, oldname, const char __user *, newname)
{
	return do_renameat2(AT_FDCWD, oldname, AT_FDCWD, newname, 0);
}
```

위 syscall들은 `do_renameat2()`를 호출한다.

**fs/namei.c:4491**
```c
static int do_renameat2(int olddfd, const char __user *oldname, int newdfd,
			const char __user *newname, unsigned int flags)
{
	struct dentry *old_dentry, *new_dentry;
	struct dentry *trap;
	struct path old_path, new_path;
	struct qstr old_last, new_last;
	int old_type, new_type;
	struct inode *delegated_inode = NULL;
	struct filename *from;
	struct filename *to;
	unsigned int lookup_flags = 0, target_flags = LOOKUP_RENAME_TARGET;
	bool should_retry = false;
	int error;

	if (flags & ~(RENAME_NOREPLACE | RENAME_EXCHANGE | RENAME_WHITEOUT))
		return -EINVAL;

	if ((flags & (RENAME_NOREPLACE | RENAME_WHITEOUT)) &&
	    (flags & RENAME_EXCHANGE))
		return -EINVAL;

	if ((flags & RENAME_WHITEOUT) && !capable(CAP_MKNOD))
		return -EPERM;

	if (flags & RENAME_EXCHANGE)
		target_flags = 0;

retry:
	from = filename_parentat(olddfd, getname(oldname), lookup_flags,
				&old_path, &old_last, &old_type);
	if (IS_ERR(from)) {
		error = PTR_ERR(from);
		goto exit;
	}

	to = filename_parentat(newdfd, getname(newname), lookup_flags,
				&new_path, &new_last, &new_type);
	if (IS_ERR(to)) {
		error = PTR_ERR(to);
		goto exit1;
	}

	error = -EXDEV;
	if (old_path.mnt != new_path.mnt)
		goto exit2;

	error = -EBUSY;
	if (old_type != LAST_NORM)
		goto exit2;

	if (flags & RENAME_NOREPLACE)
		error = -EEXIST;
	if (new_type != LAST_NORM)
		goto exit2;

	error = mnt_want_write(old_path.mnt);
	if (error)
		goto exit2;

retry_deleg:
	trap = lock_rename(new_path.dentry, old_path.dentry);

	old_dentry = __lookup_hash(&old_last, old_path.dentry, lookup_flags);
	error = PTR_ERR(old_dentry);
	if (IS_ERR(old_dentry))
		goto exit3;
	/* source must exist */
	error = -ENOENT;
	if (d_is_negative(old_dentry))
		goto exit4;
	new_dentry = __lookup_hash(&new_last, new_path.dentry, lookup_flags | target_flags);
	error = PTR_ERR(new_dentry);
	if (IS_ERR(new_dentry))
		goto exit4;
	error = -EEXIST;
	if ((flags & RENAME_NOREPLACE) && d_is_positive(new_dentry))
		goto exit5;
	if (flags & RENAME_EXCHANGE) {
		error = -ENOENT;
		if (d_is_negative(new_dentry))
			goto exit5;

		if (!d_is_dir(new_dentry)) {
			error = -ENOTDIR;
			if (new_last.name[new_last.len])
				goto exit5;
		}
	}
	/* unless the source is a directory trailing slashes give -ENOTDIR */
	if (!d_is_dir(old_dentry)) {
		error = -ENOTDIR;
		if (old_last.name[old_last.len])
			goto exit5;
		if (!(flags & RENAME_EXCHANGE) && new_last.name[new_last.len])
			goto exit5;
	}
	/* source should not be ancestor of target */
	error = -EINVAL;
	if (old_dentry == trap)
		goto exit5;
	/* target should not be an ancestor of source */
	if (!(flags & RENAME_EXCHANGE))
		error = -ENOTEMPTY;
	if (new_dentry == trap)
		goto exit5;

	error = security_path_rename(&old_path, old_dentry,
				     &new_path, new_dentry, flags);
	if (error)
		goto exit5;
	error = vfs_rename(old_path.dentry->d_inode, old_dentry,
			   new_path.dentry->d_inode, new_dentry,
			   &delegated_inode, flags);
exit5:
	dput(new_dentry);
exit4:
	dput(old_dentry);
exit3:
	unlock_rename(new_path.dentry, old_path.dentry);
	if (delegated_inode) {
		error = break_deleg_wait(&delegated_inode);
		if (!error)
			goto retry_deleg;
	}
	mnt_drop_write(old_path.mnt);
exit2:
	if (retry_estale(error, lookup_flags))
		should_retry = true;
	path_put(&new_path);
	putname(to);
exit1:
	path_put(&old_path);
	putname(from);
	if (should_retry) {
		should_retry = false;
		lookup_flags |= LOOKUP_REVAL;
		goto retry;
	}
exit:
	return error;
}
```

**call trace**
```c
[#0] 0xffffffff81281810 → ext4_xattr_set_entry(i=0xffffc90000763b40, s=0xffff88007b60c400, handle=0xffff88007be98000, inode=0xffff88007782bb18, is_block=0x0)
[#1] 0xffffffff81282759 → ext4_xattr_ibody_set(handle=<optimized out>, inode=0xffff88007782bb18, i=<optimized out>, is=0xffff88007b60c400)
[#2] 0xffffffff81284f8f → ext4_xattr_move_to_block(entry=<optimized out>, raw_inode=<optimized out>, inode=<optimized out>, handle=<optimized out>)
[#3] 0xffffffff81284f8f → ext4_xattr_make_inode_space(total_ino=<optimized out>, bfree=0xffffffffffffff58, ifree=<optimized out>, isize_diff=<optimized out>, raw_inode=<optimized out>, inode=<optimized out>, handle=<optimized out>)
[#4] 0xffffffff81284f8f → ext4_expand_extra_isize_ea(inode=<optimized out>, new_extra_isize=<optimized out>, raw_inode=<optimized out>, handle=<optimized out>)
[#5] 0xffffffff812469c7 → __ext4_expand_extra_isize(inode=0xffff88007782bb18, new_extra_isize=0x32, iloc=<optimized out>, handle=<optimized out>, no_expand=<optimized out>)
[#6] 0xffffffff8124c145 → ext4_try_to_expand_extra_isize(handle=<optimized out>, iloc={
  bh = 0xffff88007bffd680,
  offset = 0x0,
  block_group = 0x0
}, new_extra_isize=<optimized out>, inode=<optimized out>)
[#7] 0xffffffff8124c145 → ext4_mark_inode_dirty(handle=0xffff88007be98000, inode=0xffff88007782bb18)
[#8] 0xffffffff81245748 → ext4_delete_inline_entry(handle=0xffff88007be98000, dir=0xffff88007782bb18, de_del=0xffff880076d4242c, bh=0xffff88007bffd680, has_inline_data=0x38 <irq_stack_union+56>)
[#9] 0xffffffff812633a6 → ext4_delete_entry(handle=0xffff88007be98000, dir=0xffff88007782bb18, de_del=0xffff880076d4242c, bh=0xffff88007bffd680)
```
